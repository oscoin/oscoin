=====
NOTES
=====

Architecture
------------

Notes on code architecture for the light-node.

NodeT
^^^^^

``NodeT`` captures all effects and capabilities of the light-node. The question
of what base monad to use with ``NodeT`` is important. We have two choices:

  1. ``STM``
  2. ``IO``

With ``IO``,  we say that any effect can be obtained at will. This is powerful,
but doesn't give us any safety or ability to reason about what can and cannot
occure in this monad.

With ``STM``, we are able to communicate between threads, run operations
atomically and access read/write state. However, no networking is available,
no randomness and no access to a clock. If these are needed, they have to be
accessed through an ``STM`` var, ex::

    -- | Get the amount of time passed in the form of "ticks". Each tick
    -- represents an atomic amount of time.
    getTicks :: STM [Tick]

    -- | Get a random number. This reads from a lazy list of random numbers.
    getRandom :: STM Rand

    -- | Send a message to a network peer. A separate thread reads messages
    -- from a TQueue and writes them to the socket.
    sendMessage :: Peer -> Message -> STM ()

    -- | Receive a message from a peer. A separtae thread reads messages
    -- from the peer socket and writes them to a TQueue.
    recvMessage :: Peet -> STM Message

Alternatively, we send an ``IO`` through an ``STM`` channel::

    performIO :: IO a -> STM b

This executes the ``IO`` action in another thread. To execute the IO, we do::

    join . atomically $ io

since we get a ``IO (IO a)`` from ``atomically``.

-------------------------------------------------------------------------------

Another way to think about this problem is to push IO to the edges. In that
case, we run our ``NodeT`` stack for the lifetime of a request, or other kind
of "cycle". For the API, this is already the case, we have an ``ApiAction``
monad which captures this pattern. For consensus and p2p we don't have a clear
request/response architecure, which complicates things. One idea is something
like::

    loop :: ConsensusT r a -> IO ()
    loop r consensus = do
        (r', result) <- runConsensusT consensus r
        processResult result
        loop r' consensus

With the style, we run the consensus in distinct "ticks". Each tick returns
a result which when processed may invoke IO.

-------------------------------------------------------------------------------

Can we come up with a typeclass to represent blockchains?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

  class Blockchain a where
    type Transaction a :: *

    apply :: Transaction a -> a -> a
    genesis :: a

    default genesis :: Default a => a
    genesis = def


Why blockchain?
^^^^^^^^^^^^^^^

What characteristics of blockchains are interesting and not available in other
architectures? The purported attributes are:

* *Tamper-proof*: You can't go back and edit a transaction in the past. Also
  known as 'immutable'.
* *Censor-proof*: All transactions, if valid get included in the ledger.

However, these are really only valid in either PoW blockchains or in open
networks, the reason being that otherwise, it's up to the validators whether
the ledger gets tampered with or if transactions are censored. In an open
network, that is also the case, but the validators are much less likely to
collude.

If we don't have a blockchain:

* How do we handle the case of stake-holders voting for their validators? Can
this be done without a chain?
* How do you "fork" a DL if it isn't blockchain-based?
* How do you create an org that isn't owned by anyone? For example to share some
code that requires a multisig to take down, but every member can write to?

Blockchain is future-proof. We don't have to stay with PoA; orgs can decide
to go for more decentralized networks down the line. They can use delegated
voting etc.

.. vim: filetype=rst
