=======
HACKING
=======

User flows
----------

Conceptually, we can start by tracing the path of a user action from the CLI to
the blockchain. This gives us a good overview of the different components and
how they relate to each other.

Push flow
^^^^^^^^^

1. A user executes the shell command ``git push oscoin://monadic/lambda.git master``
2. ``git`` searches for an executable called ``git-remote-oscoin``
3. The executable's job is to construct the appropriate HTTP query for one of
   our nodes. This query includes all of the push data in JSON form.
4. The node receives the payload, parses it and creates a *PatchTx* transaction.
5. This transaction is stored in the node's mempool, as well as broadcast to its
   peers.
6. It's this node's turn to propose a block. The node gathers all the transactions
   in its mempool, constructs a block, and broadcasts it to its peers.
7. The peers verify the block header, process and verify all transactions, update
   their internal state tree and add the block to storage.
8. The new replicated state of the network now includes the user's changes.

Pull flow
^^^^^^^^^

1. A user executes the shell command ``git pull oscoin://monadic/lambda.git master``
2. ``git`` searches for an executable called ``git-remote-oscoin``
3. The executable's job is to query a node asking it for changes in
   ``monadic/lambda.git`` and apply them to the working tree.
4. The node receives this request, looks at its state tree, under
   ``monadic/lambda/master``, builds a json object containing the relevant
   changes, and responds to the client.
5. The client constructs the appropriate git object(s) from the response, and
   updates the repository head.

.. vim: filetype=rst
